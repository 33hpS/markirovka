#!/usr/bin/env python
"""purge_history_remove_node_modules.py

Minimal helper to rewrite git history and remove any tracked node_modules content
from every past commit using git-filter-repo.

SAFE STEPS IT PERFORMS:
 1. Verifies inside a git repository and that the working tree is clean (unless --force).
 2. Creates a local backup branch (configurable) pointing to current HEAD.
 3. Ensures git-filter-repo is available (installs via pip if permitted / --auto-install).
 4. Runs git filter-repo with --invert-paths --path node_modules
 5. Runs aggressive repack & GC to shrink repo size.
 6. Prints next-step instructions for force pushing.

USAGE EXAMPLES (PowerShell):
  python scripts/purge_history_remove_node_modules.py --dry-run
  python scripts/purge_history_remove_node_modules.py --execute
  python scripts/purge_history_remove_node_modules.py --execute --backup-branch backup/pre-purge-$(Get-Date -Format yyyyMMddHHmmss)
  python scripts/purge_history_remove_node_modules.py --execute --no-gc

ARGUMENTS:
  --execute            Actually perform rewrite (otherwise only prints what would happen)
  --backup-branch NAME Custom backup branch name (default: backup/pre-node-modules-purge)
  --force              Skip clean working tree check
  --auto-install       Attempt to install git-filter-repo if missing
  --no-gc              Skip git GC after rewrite
  --dry-run            Synonym for default (no rewrite) – shows detection & planned command

AFTER SUCCESS:
  git push origin main --force-with-lease
  (and optionally delete the backup branch later)

DISCLAIMER: Rewriting public history is a destructive operation. Coordinate with collaborators.
"""
from __future__ import annotations

import argparse
import os
import shutil
import subprocess
import sys
from datetime import datetime


def run(cmd: list[str], check: bool = True, capture: bool = False, **kwargs):
    """Run a shell command."""
    print(f"[run] {' '.join(cmd)}")
    result = subprocess.run(cmd, text=True, capture_output=capture, **kwargs)
    if check and result.returncode != 0:
        if capture:
            sys.stderr.write(result.stdout)
            sys.stderr.write(result.stderr)
        raise SystemExit(f"Command failed with exit code {result.returncode}: {' '.join(cmd)}")
    return result


def git(*args: str, capture: bool = False, check: bool = True):
    return run(["git", *args], check=check, capture=capture)


def ensure_clean(force: bool):
    if force:
        print("[info] --force supplied: skipping clean working tree check")
        return
    r = git("status", "--porcelain", capture=True)
    if r.stdout.strip():
        raise SystemExit("Working tree not clean. Commit/stash or use --force.")
    print("[ok] Working tree clean")


def ensure_repo():
    if not os.path.isdir(".git"):
        raise SystemExit("Not inside the root of a git repository (no .git directory found).")
    git("rev-parse", "--is-inside-work-tree")
    print("[ok] Inside git repository")


def create_backup(branch: str):
    # If branch exists, append timestamp suffix
    existing = git("branch", "--list", branch, capture=True).stdout.strip()
    final = branch
    if existing:
        ts = datetime.utcnow().strftime("%Y%m%d%H%M%S")
        final = f"{branch}-{ts}"
        print(f"[warn] Backup branch '{branch}' already exists. Using '{final}' instead.")
    git("branch", final)
    print(f"[ok] Created backup branch: {final}")
    return final


def check_filter_repo(auto_install: bool):
    exe = shutil.which("git-filter-repo")
    if exe:
        print(f"[ok] git-filter-repo found: {exe}")
        return True
    print("[warn] git-filter-repo not found in PATH")
    if not auto_install:
        print("[hint] Install via: pip install git-filter-repo  OR  see https://github.com/newren/git-filter-repo")
        return False
    print("[info] Attempting auto install via pip")
    try:
        run([sys.executable, "-m", "pip", "install", "--user", "git-filter-repo"], check=True)
    except SystemExit:
        print("[error] Auto install failed.")
        return False
    exe = shutil.which("git-filter-repo")
    if not exe:
        print("[error] git-filter-repo still not found after install.")
        return False
    print(f"[ok] Installed git-filter-repo: {exe}")
    return True


def do_rewrite(no_gc: bool):
    print("[action] Rewriting history – removing all tracked 'node_modules' content")
    run([
        "git", "filter-repo",
        "--force",
        "--invert-paths",
        "--path", "node_modules"
    ])
    print("[ok] History rewrite complete")
    if not no_gc:
        print("[action] Running aggressive GC / repack")
        # Deep clean & optimize
        git("reflog", "expire", "--expire=now", "--all")
        git("gc", "--prune=now", "--aggressive")
        print("[ok] GC complete")
    else:
        print("[skip] GC skipped (--no-gc)")


def print_next_steps(backup_branch: str):
    print("\nNEXT STEPS:")
    print(f"  1. Review rewrite: git log --oneline | head")
    print(f"  2. Force push:    git push origin main --force-with-lease")
    print(f"  3. Inform team: history rewritten; re-clone or hard reset required.")
    print(f"  4. Keep backup branch '{backup_branch}' until fully confident, then optionally:")
    print(f"       git push origin :{backup_branch}")
    print("  5. (Optional) Invalidate caches (CI services may need a fresh clone)")


def main():
    parser = argparse.ArgumentParser(description="Rewrite git history removing node_modules from past commits.")
    parser.add_argument("--execute", action="store_true", help="Perform the rewrite (omit for dry-run)")
    parser.add_argument("--dry-run", action="store_true", help="Show what would happen (default if --execute absent)")
    parser.add_argument("--backup-branch", default="backup/pre-node-modules-purge", help="Name of backup branch")
    parser.add_argument("--force", action="store_true", help="Skip clean working tree check")
    parser.add_argument("--auto-install", action="store_true", help="Attempt pip install of git-filter-repo if missing")
    parser.add_argument("--no-gc", action="store_true", help="Skip GC after rewrite")
    args = parser.parse_args()

    ensure_repo()
    ensure_clean(force=args.force)

    backup = create_backup(args.backup_branch)

    available = check_filter_repo(auto_install=args.auto_install)
    if not available:
        raise SystemExit("git-filter-repo unavailable – aborting.")

    if not args.execute:
        print("[dry-run] Would run: git filter-repo --force --invert-paths --path node_modules")
        print("[dry-run] Re-run with --execute to perform rewrite.")
        print_next_steps(backup)
        return

    do_rewrite(no_gc=args.no_gc)
    print_next_steps(backup)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[abort] Interrupted by user")
        sys.exit(130)